# 计算机组成

## 数据表示和运算

### bcd码

二进制编码的十进制数

#### 8421码

个个位数权值由高到低为8,4,2,1,8421码在相加大于10（1010）时，需要加6修正。

### 校验码

码距 两个码直接变化最小的位的位数

#### 奇偶校验码

在原编码上加校验位，码距为2。

由若干有效信息和一个二进制位组成校验码： 奇校验码 整个生成码1的个数为奇数    偶校验码 整个生成码的1的个数为偶数

#### 海明码

在有效信息位中加入几个校验位形成海明码，并把海明码的每一个二进制位分配到奇偶校验组中

海明码包括 n 有效信息的位数 k 校验位的位数 满足条件 
$$
n+k<=2^k-1
$$

构建过程 ：

1 确认校验位的分布

​	规定校验位p<sub>i</sub>在海明位号为2<sup>i-1</sup>的位置上其余为信息位

2 分组

​	每个数据使用多个校验位进行校验，被校验数据位的海明位号等于起校验作用的校验位的海明位和，校验位不需要校验一个校验位对应一个组，组中元素为其校验的海明位

3 校验位取值

​	校验位的值为其所对应的集合的所有元素的异或

4 校验原理

​	每个集合中的元素的异或和集合所对应的校验位进行异或，所有结果拼起来，形成一个二进制数，若全为0,说明无错误，若不为零，说明二进制数对应的位数出现问题。

#### 循环冗余校验码 （crc）码

在k位信息码后拼接r位的校验码，整个编码的长度为n

构建过程

1 将生成多项式转为二进制编码 

2 R=生成多项式最高幂 ，K=信息位长度 ，N=R+K

3 将信息位左移R位，低位补零

4 相除，对移位后的信息码用生成多项式对应的二进制编码相除(模2)，产生余数。

##### 模2除法

​	1.先使用对应位数相除，结果位为被除数的高位

​    2.剩下位数进行异或计算

​    3.被除数下移一位，重复进行

​	4.得到余数

5 将余数添加到原信息之后，得到crc码

检验和纠错

对接受段的数据用生成多项式进行模2除法，若为0，则无错误，若为其他，说明对应位出错

### 定点数

#### 定点数的表示

##### 无符号数

整个机器字长全部为数值位，没有符号位

##### 有符号数 

最高位为符号位，0表示副号，1表示正号

##### 定点小数

纯小数，约定小数点在符号位之后，最大正数1-2<sup> -n</sup>最小负数 -（1-2<sup> -n</sup>）

##### 定点整数

 纯整数，小数点位置在有效数值部分最低位之后，小数点隐含（不存在) ,最大正数2<sup> n</sup>-1 ，最小负数 -（2<sup>n</sup> -1)

##### 原码

最高位表示符号，其余表示数的绝对值（原码只表示纯整数或者纯小数）

##### 补码

将加减法操作统一为加法操作

纯小数的补码定义：

​				x补 = x （1 > x >= 0)

​				x补 =  2+x = 2 - |x| （0>x>=-1)

纯整数的补码定义

​				x补 = x （2<sup>n</sup> >x >= 0)

​				x补 =  2<sup>n+1</sup>+x = 2<sup>n+1</sup> - |x| （0>x>=-2<sup>n</sup>)

更常见的方法为正数不变，负数各位取反，末尾加1

补码正负的切换：符号位取反，正数到负数加1,负数到正数减1

##### 反码

过度码，正数不变，负数各位取反

##### 移码

在真值x上加一个常数（一般为2<sup>n</sup> ,相当于x在数轴上向正方向偏移若干单位 ）在补码的基础上将符号位取反，移码有随着真值递增而递增的性质，方便移码表示的整数比对大小。

#### 定点数的计算

##### 算数移位

###### 原码的算数位移

改变各各数码位和小数点的相对位置，从而改变各数码位的位权,符号位保持不变，对数值进行位移

右移 ：高位补0,低位舍弃，若舍弃位为0,相当于除以2,舍弃位不为零，舍弃精度，向下取正 

左移： 低位补0,高位舍弃，若舍弃位为0,相当于乘2,舍弃位不为0,出现严重误差

###### 反码的算数位移

正数和原码相同，负数高位和低位补1

###### 补码的算数位移

正数和原码相同，负数右移高位补1,低位舍弃，左移低位补0,高位舍弃 

##### 逻辑移位

逻辑右移，高位补0,低位舍弃；逻辑左移，低位补0,高位舍弃

##### 循环移位

将移位舍弃的位补在新出现的空位之上（可用于高低位字节的互换）

##### 加减运算

###### 原码的加减运算

加法 ：符号位相同，绝对值相加，符号位保持不变；若不同，做减法，绝对值大的树减去绝对值小的数，符号位和绝对值大的数相同

减法 ： 将减法符号取反，然后将减数符号取反，然后将被减数和取反后的减数按照加法规则进行运算。

###### 补码定点数加减运算

符号位与数值位同时参与运算，符号位运算产生的进位丢弃，结果的符号位由运算得到，得到的结果仍为补码

##### 溢出判断

###### 一位符号位

参加操作的两个数符号相同，结果和原操作数不同，发生结果溢出

###### 一位符号位加最高数值位

符号位的进位数和最高数值位的进位数不同，发生溢出

上溢 ：符号位的进位为0,最高数值位的进位为1

下溢 ：符号位的进位为1,最高数值位的进位为0

###### 两位符号位（模4补码）

将符号位重复一次再进行运算，两位符号位相同，不发生溢出，两位符号位不同，01发生上溢，10发生下溢

##### 乘除运算

###### 原码的乘法运算

两个数均取绝对值进行运算，符号位为x异或y

![file:///home/gfy/Pictures/Screenshot_20210412_141633.png](file:///home/gfy/Pictures/Screenshot_20210412_141633.png)

ACC中存放乘积高位，MQ中存放乘数和乘积低位，X中存放被乘数

实现方法，先进行加法运算，后进行移位运算，将MQ中数最低位进行判断，若为1,将X中数通过ALU加法单元加至ACC上，将ACC和MQ连起来逻辑右移一位，重复操作至乘数的数值位全部移除，最后修改符号位

###### 补码的乘法运算

在实现原码乘法运算的基础运算器上额外增添一位，MQ在最后增添辅助位，X和ACC在前增添符号位

实现方法，用辅助位减去MQ中最低位 ，=1时，ACC+X；=0时，ACC不变；=-1时，ACC+[-x]<sub>补</sub> ，完成后对ACC和MQ整体算数右移，重复n次，最后和原码的乘法不同，需额外进行一次加法运算，最后输出结果

###### 原码的除法运算

恢复余数法

两个数均取绝对值进行运算，符号位为x异或y

MQ的最后一位默认为1,表示当前确定的一位商，之后将ACC中的原码和X中的数的负数的补码相加（[-x]<sub>补</sub> ），结果存入ACC中，若数字为负数，将MQ最后一位改为0,将ACC中的数重新加上[X]<sub>补</sub>来恢复余数，之后将ACC和MQ逻辑左移，重复操作，操作步数由机械字长决定

加减交替法

商的正负和恢复余数法得到的相同

计算余数的方法和恢复余数法相同，若余数为负，可直接商0,让余数左移一位再加除数的绝对值，得到下一个新余数，重复操作，最后一步余数为负时，恢复余数

###### 补码的除法运算

加减交替法

符号位参与运算，采用双符号位，被除数和除数同号，则被除数减去除数得到余数；异号则被除数加上除数得到余数，余数和除数同号，商1，余数左移一位减去除数，余数和除数异号，商0，除数左移一位加上余数，末尾商恒为1

#### 强制类型转化 

无符号数和有符号数，不改变数据；长整数变为短整数，高位截断，保留低位；短整数变长整数，符号扩展

### 浮点数

扩大数的表示范围，保持数的有效精度

#### 表示方式

浮点数被表示为阶码和尾数的拼接 ，阶码由阶符和数值组成，阶符表示阶码的正负；尾数由数符和数值构成，数符表示浮点数的正负， 浮点数的值的计算为 ：X = r<sup> E</sup> * M 

r是阶码的底数，通常为2,E为阶码的数值部分，M是尾数的数值部分

#### 规格化

规定尾数的最高数位一定为有效数值1

左规：将尾数算数左移一位，阶码减1,目的为增加精度

右规：将尾数算数右移一位，阶码加1，若运算结果出现溢出（双符号位符号不同），防止溢出

#### IEEE 754 标准

尾数为原码数，规范化之后的尾数首位定为1,所以隐藏尾数，阶码为移码，存在偏置值

##### 短浮点数

数符为1位,阶码为8位,尾数数值23位,总位数32位，阶码的偏置值为127

##### 长浮点数

数符为1位，阶码为11位，尾数数值52位，总共64位，阶码的偏置值为1023

#### 浮点数加减运算

1.对阶

将操作数的浮点对齐，使其阶码相等，小阶向大阶看齐，因为尾数是定点小数

2.尾数加减

对尾数进行加减

3.规格化

浮点数的规格化（左规，右规）

4.舍入

对计算结果按照规定进行舍入（保留n位，去位，进位，四舍五入等）

5.判断溢出

判断阶码是否溢出

### 算数逻辑单元ALU

#### 一位全加器

输入： 加数A；加数B；进位C

输出 本位S；进位C

和的表达式 

S =A $\bigoplus$ B $\bigoplus$ C

进位表达式

C = AB + (A$\bigoplus$ B) C

#### 串行加法器

 只有一个全加器，数字逐位串行送入加法器（一位全加器）进行运算，通过增加进位触发器来寄存进位信号，
